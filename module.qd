/// Base64 encoding and decoding.
/// Optimized with lookup tables and direct buffer writes.
use mem
use str
use unicode

// Build base64 encoding lookup table (64 bytes)
fn make_enc_table( -- tbl:ptr) {
	64 mem::alloc! -> tbl
	// A-Z (0-25)
	0 26 1 for it {
		unicode::A it + tbl it mem::set_byte
	}
	// a-z (26-51)
	26 52 1 for it {
		unicode::a it 26 - + tbl it mem::set_byte
	}
	// 0-9 (52-61)
	52 62 1 for it {
		unicode::digit0 it 52 - + tbl it mem::set_byte
	}
	// + (62)
	unicode::plus tbl 62 mem::set_byte
	// / (63)
	unicode::slash tbl 63 mem::set_byte
	tbl
}

// Build base64 decoding lookup table (128 bytes, -1 for invalid, -2 for '=')
fn make_dec_table( -- tbl:ptr) {
	128 mem::alloc! -> tbl
	// Initialize all to -1 (invalid)
	255 tbl 128 mem::fill
	// A-Z -> 0-25
	0 26 1 for it {
		it tbl unicode::A it + mem::set_byte
	}
	// a-z -> 26-51
	0 26 1 for it {
		26 it + tbl unicode::a it + mem::set_byte
	}
	// 0-9 -> 52-61
	0 10 1 for it {
		52 it + tbl unicode::digit0 it + mem::set_byte
	}
	// + -> 62
	62 tbl unicode::plus mem::set_byte
	// / -> 63
	63 tbl unicode::slash mem::set_byte
	// = -> 254 (padding marker, will check separately)
	254 tbl unicode::equals mem::set_byte
	tbl
}

/// Encode a string to base64.
/// @param input str String to encode
/// @return encoded str Base64-encoded string
/// @example "Hello" base64::encode -> b64
pub fn encode(input:str -- encoded:str) {
	-> input
	input mem::from_string -> inlen -> buf

	// Build lookup table
	make_enc_table -> enc_tbl

	// Calculate output size: ceil(inlen/3) * 4
	inlen 2 + 3 / 4 * -> outlen
	outlen mem::alloc! -> out

	0 -> i
	0 -> o
	0 -> b1
	0 -> b2
	0 -> b3
	0 -> idx

	loop {
		i inlen >= if {
			break
		}

		// Get up to 3 bytes
		buf i mem::get_byte -> b1
		i 1 + inlen < if {
			buf i 1 + mem::get_byte
		} else {
			0
		}
		-> b2
		i 2 + inlen < if {
			buf i 2 + mem::get_byte
		} else {
			0
		}
		-> b3

		// Char 1: top 6 bits of b1
		b1 2 shr 63 and -> idx
		enc_tbl idx mem::get_byte out o mem::set_byte
		o 1 + -> o

		// Char 2: bottom 2 bits of b1 + top 4 bits of b2
		b1 3 and 4 shl b2 4 shr or -> idx
		enc_tbl idx mem::get_byte out o mem::set_byte
		o 1 + -> o

		// Char 3: bottom 4 bits of b2 + top 2 bits of b3 (or padding)
		i 1 + inlen < if {
			b2 15 and 2 shl b3 6 shr or -> idx
			enc_tbl idx mem::get_byte out o mem::set_byte
		} else {
			unicode::equals out o mem::set_byte
		}
		o 1 + -> o

		// Char 4: bottom 6 bits of b3 (or padding)
		i 2 + inlen < if {
			b3 63 and -> idx
			enc_tbl idx mem::get_byte out o mem::set_byte
		} else {
			unicode::equals out o mem::set_byte
		}
		o 1 + -> o

		i 3 + -> i
	}

	buf mem::free
	enc_tbl mem::free
	out outlen mem::to_string -> result
	out mem::free
	result
}

/// Decode a base64 string.
/// @param encoded str Base64-encoded string
/// @return decoded str Decoded string
/// @example "SGVsbG8=" base64::decode -> text
pub fn decode(encoded:str -- decoded:str) {
	-> encoded
	encoded mem::from_string -> enclen -> inbuf

	enclen 0 == if {
		inbuf mem::free
		""
	} else {
		// Build lookup table
		make_dec_table -> dec_tbl

		// Allocate output buffer (max 3/4 of input length)
		enclen 3 * 4 / 1 + mem::alloc! -> buf
		0 -> o
		0 -> i
		0 -> v1
		0 -> v2
		0 -> v3
		0 -> v4
		0 -> b1
		0 -> b2
		0 -> b3

		loop {
			i enclen >= if {
				break
			}

			// Get 4 base64 values via lookup (direct buffer access)
			dec_tbl inbuf i mem::get_byte mem::get_byte -> v1
			dec_tbl inbuf i 1 + mem::get_byte mem::get_byte -> v2
			dec_tbl inbuf i 2 + mem::get_byte mem::get_byte -> v3
			dec_tbl inbuf i 3 + mem::get_byte mem::get_byte -> v4

			// Skip invalid (255 = -1 as unsigned byte)
			v1 255 == v2 255 == or if {
				i 4 + -> i
				continue
			}

			// Decode byte 1
			v1 2 shl v2 4 shr or 255 and -> b1
			b1 buf o mem::set_byte
			o 1 + -> o

			// Decode byte 2 (if not padding, 254 = '=')
			v3 254 != v3 255 != and if {
				v2 15 and 4 shl v3 2 shr or 255 and -> b2
				b2 buf o mem::set_byte
				o 1 + -> o
			}

			// Decode byte 3 (if not padding)
			v4 254 != v4 255 != and if {
				v3 3 and 6 shl v4 or 255 and -> b3
				b3 buf o mem::set_byte
				o 1 + -> o
			}

			i 4 + -> i
		}

		inbuf mem::free
		dec_tbl mem::free
		buf o mem::to_string -> result
		buf mem::free
		result
	}
}
